#!/usr/bin/env node
import { execSync, spawn, exec } from 'child_process';
import fs4, { existsSync, mkdirSync, copyFileSync } from 'fs';
import path2, { dirname, join } from 'path';
import { fileURLToPath } from 'url';

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/loops.config.js
var CHANNELS, channel, ENABLED_LOOPS;
var init_loops_config = __esm({
  "src/loops.config.js"() {
    CHANNELS = {
      dev: ["burn", "visualization", "backend"],
      staging: ["burn", "visualization", "backend"],
      prod: ["burn", "visualization", "backend"]
    };
    channel = "prod";
    ENABLED_LOOPS = CHANNELS[channel] || CHANNELS.prod;
  }
});
function commandExists(cmd) {
  try {
    execSync(`which ${cmd}`, { encoding: "utf-8", stdio: "pipe" });
    return true;
  } catch {
    return false;
  }
}
function isInstalledLocally(pkg, rootDir) {
  return fs4.existsSync(path2.join(rootDir, "node_modules", pkg));
}
function installPackage(pkg, rootDir) {
  try {
    console.log(`   Installing ${pkg}...`);
    execSync(`cd "${rootDir}" && npm install --save-dev ${pkg}`, {
      encoding: "utf-8",
      stdio: "pipe"
    });
    return true;
  } catch (e) {
    return false;
  }
}
function hasEslintConfig(rootDir) {
  const configFiles = [
    "eslint.config.js",
    "eslint.config.mjs",
    "eslint.config.cjs",
    // Legacy configs (ESLint < 9)
    ".eslintrc.js",
    ".eslintrc.cjs",
    ".eslintrc.json",
    ".eslintrc.yml",
    ".eslintrc.yaml",
    ".eslintrc"
  ];
  return configFiles.some((file) => fs4.existsSync(path2.join(rootDir, file)));
}
function createEslintConfig(rootDir, config) {
  var _a4;
  const rules = ((_a4 = config.eslint) == null ? void 0 : _a4.rules) || ["no-unused-vars"];
  const rulesObj = {};
  for (const rule of rules) {
    rulesObj[rule] = "error";
  }
  const rulesJson = JSON.stringify(rulesObj, null, 2).replace(/\n/g, "\n    ");
  const configContent = `// Auto-generated by bonzai-burn for ESLint v9+
export default [
  {
    files: ['**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx', '**/*.mjs', '**/*.cjs'],
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'module',
      parserOptions: {
        ecmaFeatures: {
          jsx: true
        }
      }
    },
    rules: ${rulesJson}
  }
];
`;
  const configPath = path2.join(rootDir, "eslint.config.js");
  try {
    fs4.writeFileSync(configPath, configContent, "utf-8");
    return true;
  } catch (e) {
    return false;
  }
}
function ensureEslint(rootDir, config) {
  const cfg = config.eslint || {};
  if (!cfg.enabled) {
    return { available: false, reason: "Disabled in config" };
  }
  let eslintInstalled = commandExists("eslint") || isInstalledLocally("eslint", rootDir);
  let installed = false;
  if (!eslintInstalled) {
    console.log("\u{1F4E6} ESLint not found, installing...");
    if (installPackage("eslint", rootDir)) {
      eslintInstalled = true;
      installed = true;
    } else {
      return { available: false, reason: "Failed to install ESLint" };
    }
  }
  let configCreated = false;
  if (!hasEslintConfig(rootDir)) {
    console.log("\u{1F4C4} Creating eslint.config.js...");
    if (createEslintConfig(rootDir, config)) {
      configCreated = true;
    } else {
      return { available: false, reason: "Failed to create ESLint config" };
    }
  }
  return { available: true, installed, configCreated };
}
function ensureTypeScript(rootDir, config) {
  const cfg = config.typescript || {};
  if (!cfg.enabled) {
    return { available: false, reason: "Disabled in config" };
  }
  if (!fs4.existsSync(path2.join(rootDir, "tsconfig.json"))) {
    return { available: false, reason: "No tsconfig.json found" };
  }
  if (commandExists("tsc") || isInstalledLocally("typescript", rootDir)) {
    return { available: true };
  }
  console.log("\u{1F4E6} TypeScript not found, installing...");
  if (installPackage("typescript", rootDir)) {
    return { available: true, installed: true };
  }
  return { available: false, reason: "Failed to install TypeScript" };
}
function listAllFiles(dir, basePath = "") {
  const ignorePatterns = ["node_modules", ".git", ".DS_Store", "dist", "build", "coverage", "bonzai"];
  let results = [];
  try {
    const entries = fs4.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path2.join(dir, entry.name);
      const relativePath = path2.join(basePath, entry.name);
      if (ignorePatterns.some((p) => entry.name === p) || entry.name.startsWith(".")) {
        continue;
      }
      if (entry.isDirectory()) {
        results = results.concat(listAllFiles(fullPath, relativePath));
      } else {
        results.push({
          path: relativePath,
          fullPath
        });
      }
    }
  } catch (e) {
  }
  return results;
}
function runEslintAnalysis(rootDir, config) {
  const issues = [];
  const cfg = config.eslint || {};
  if (!cfg.enabled) {
    return { issues, skipped: true, reason: "Disabled in config" };
  }
  const rules = cfg.rules || ["no-unused-vars"];
  const ruleArgs = rules.map((r) => `--rule "${r}: error"`).join(" ");
  const eslintCmd = isInstalledLocally("eslint", rootDir) ? `"${path2.join(rootDir, "node_modules", ".bin", "eslint")}"` : "eslint";
  try {
    const result = execSync(
      `${eslintCmd} "${rootDir}" --format json ${ruleArgs} --ignore-pattern node_modules --ignore-pattern bonzai 2>/dev/null || true`,
      { encoding: "utf-8", stdio: "pipe", maxBuffer: 50 * 1024 * 1024 }
    );
    if (result.trim()) {
      const eslintOutput = JSON.parse(result);
      for (const file of eslintOutput) {
        for (const msg of file.messages || []) {
          if (msg.ruleId && rules.some((r) => msg.ruleId.includes(r.replace("no-", "")))) {
            issues.push({
              file: path2.relative(rootDir, file.filePath),
              line: msg.line,
              message: msg.message,
              rule: msg.ruleId
            });
          }
        }
      }
    }
  } catch (e) {
    return { issues, skipped: true, reason: "ESLint analysis failed" };
  }
  return { issues, skipped: false };
}
function runTypeScriptAnalysis(rootDir, config) {
  const issues = [];
  const cfg = config.typescript || {};
  if (!cfg.enabled) {
    return { issues, skipped: true, reason: "Disabled in config" };
  }
  const tsconfigPath = path2.join(rootDir, "tsconfig.json");
  if (!fs4.existsSync(tsconfigPath)) {
    return { issues, skipped: true, reason: "No tsconfig.json found" };
  }
  const tscCmd = isInstalledLocally("typescript", rootDir) ? `"${path2.join(rootDir, "node_modules", ".bin", "tsc")}"` : "tsc";
  try {
    const result = execSync(
      `cd "${rootDir}" && ${tscCmd} --noEmit --noUnusedLocals --noUnusedParameters 2>&1 || true`,
      { encoding: "utf-8", stdio: "pipe", maxBuffer: 50 * 1024 * 1024 }
    );
    const lines = result.split("\n");
    const errorRegex = /^(.+)\((\d+),(\d+)\):\s*error\s+TS(\d+):\s*(.+)$/;
    for (const line of lines) {
      const match = line.match(errorRegex);
      if (match) {
        const [, filePath, lineNum, , errorCode, message] = match;
        if (["6133", "6196", "6198"].includes(errorCode)) {
          issues.push({
            file: path2.relative(rootDir, filePath),
            line: parseInt(lineNum, 10),
            message,
            rule: `TS${errorCode}`
          });
        }
      }
    }
  } catch (e) {
    return { issues, skipped: true, reason: "TypeScript analysis failed" };
  }
  return { issues, skipped: false };
}
function checkLineLimits(files, config) {
  const issues = [];
  const cfg = config.lineLimit || {};
  if (!cfg.enabled) {
    return { issues, skipped: true, reason: "Disabled in config" };
  }
  const maxLines = cfg.limit || 500;
  for (const file of files) {
    if (file.path.endsWith(".json") || file.path.endsWith(".lock") || file.path.endsWith(".css")) {
      continue;
    }
    try {
      const content = fs4.readFileSync(file.fullPath, "utf-8");
      const lineCount = content.split("\n").length;
      if (lineCount > maxLines) {
        issues.push({
          file: file.path,
          count: lineCount,
          limit: maxLines
        });
      }
    } catch (e) {
    }
  }
  issues.sort((a, b) => b.count - a.count);
  return { issues, skipped: false, prompt: cfg.prompt };
}
function checkFolderLimits(files, config) {
  const issues = [];
  const cfg = config.folderLimit || {};
  if (!cfg.enabled) {
    return { issues, skipped: true, reason: "Disabled in config" };
  }
  const maxItems = cfg.limit || 20;
  const folderCounts = {};
  for (const file of files) {
    const dir = path2.dirname(file.path);
    if (!folderCounts[dir]) {
      folderCounts[dir] = 0;
    }
    folderCounts[dir]++;
  }
  for (const [folder, count] of Object.entries(folderCounts)) {
    if (count > maxItems) {
      issues.push({
        file: folder,
        count,
        limit: maxItems
      });
    }
  }
  issues.sort((a, b) => b.count - a.count);
  return { issues, skipped: false, prompt: cfg.prompt };
}
function checkMissingTests(files, config) {
  const issues = [];
  const cfg = config.testCheck || {};
  if (!cfg.enabled) {
    return { issues, skipped: true, reason: "Disabled in config" };
  }
  const patterns = cfg.patterns || {
    ".vue": ".test.js",
    ".jsx": ".test.jsx",
    ".tsx": ".test.tsx"
  };
  const testFiles = new Set(
    files.filter((f) => f.path.includes(".test.") || f.path.includes(".spec.")).map((f) => f.path.toLowerCase())
  );
  for (const file of files) {
    const ext = path2.extname(file.path);
    const testExt = patterns[ext];
    if (!testExt) continue;
    if (file.path.includes(".test.") || file.path.includes(".spec.")) continue;
    if (!file.path.startsWith("src/") && !file.path.startsWith("components/")) continue;
    const baseName = path2.basename(file.path, ext);
    const hasTest = [...testFiles].some((t) => t.includes(baseName.toLowerCase()) && t.includes(".test."));
    if (!hasTest) {
      issues.push({
        file: file.path,
        expectedTest: `${baseName}${testExt}`
      });
    }
  }
  return { issues, skipped: false, prompt: cfg.prompt };
}
async function analyze(rootDir = process.cwd(), config = {}) {
  var _a4, _b, _c;
  const startTime = Date.now();
  const files = listAllFiles(rootDir);
  const toolStatus = {};
  console.log("\u{1F527} Checking tools...");
  const eslintStatus = ensureEslint(rootDir, config);
  toolStatus.eslint = eslintStatus;
  if (eslintStatus.installed && eslintStatus.configCreated) {
    console.log("   \u2713 ESLint installed + config created");
  } else if (eslintStatus.installed) {
    console.log("   \u2713 ESLint installed");
  } else if (eslintStatus.configCreated) {
    console.log("   \u2713 ESLint ready (config created)");
  } else if (eslintStatus.available) {
    console.log("   \u2713 ESLint ready");
  } else if ((_a4 = config.eslint) == null ? void 0 : _a4.enabled) {
    console.log(`   \u2717 ESLint: ${eslintStatus.reason}`);
  }
  const tsStatus = ensureTypeScript(rootDir, config);
  toolStatus.typescript = tsStatus;
  if (tsStatus.installed) {
    console.log("   \u2713 TypeScript installed");
  } else if (tsStatus.available) {
    console.log("   \u2713 TypeScript ready");
  } else if ((_b = config.typescript) == null ? void 0 : _b.enabled) {
    console.log(`   \u2717 TypeScript: ${tsStatus.reason}`);
  }
  console.log("");
  const eslint = eslintStatus.available ? runEslintAnalysis(rootDir, config) : { issues: [], skipped: true, reason: eslintStatus.reason };
  const typescript = tsStatus.available ? runTypeScriptAnalysis(rootDir, config) : { issues: [], skipped: true, reason: tsStatus.reason };
  const lineLimit = checkLineLimits(files, config);
  const folderLimit = checkFolderLimits(files, config);
  const missingTests = checkMissingTests(files, config);
  const duration = Date.now() - startTime;
  return {
    eslint,
    typescript,
    lineLimit,
    folderLimit,
    missingTests,
    customRequirements: ((_c = config.customChecks) == null ? void 0 : _c.requirements) || null,
    filesScanned: files.length,
    durationMs: duration,
    toolStatus
  };
}
function formatAnalysisResults(results) {
  var _a4, _b;
  let output = "";
  let totalIssues = 0;
  if (!results.eslint.skipped && results.eslint.issues.length > 0) {
    output += `\u{1F5D1}\uFE0F  UNUSED CODE (ESLint) - ${results.eslint.issues.length} issues
`;
    for (const issue of results.eslint.issues.slice(0, 15)) {
      output += `   ${issue.file}:${issue.line} - ${issue.message}
`;
    }
    if (results.eslint.issues.length > 15) {
      output += `   ... and ${results.eslint.issues.length - 15} more
`;
    }
    output += "\n";
    totalIssues += results.eslint.issues.length;
  }
  if (!results.typescript.skipped && results.typescript.issues.length > 0) {
    output += `\u{1F537} UNUSED CODE (TypeScript) - ${results.typescript.issues.length} issues
`;
    for (const issue of results.typescript.issues.slice(0, 15)) {
      output += `   ${issue.file}:${issue.line} - ${issue.message}
`;
    }
    if (results.typescript.issues.length > 15) {
      output += `   ... and ${results.typescript.issues.length - 15} more
`;
    }
    output += "\n";
    totalIssues += results.typescript.issues.length;
  }
  if (!results.lineLimit.skipped && results.lineLimit.issues.length > 0) {
    output += `\u{1F4CF} FILES OVER LINE LIMIT - ${results.lineLimit.issues.length} files
`;
    for (const issue of results.lineLimit.issues) {
      output += `   ${issue.file} - ${issue.count} lines (limit: ${issue.limit})
`;
    }
    if (results.lineLimit.prompt) {
      output += `
   \u2192 ${results.lineLimit.prompt.replace(/\{\{\s*linelimit\s*\}\}/gi, ((_a4 = results.lineLimit.issues[0]) == null ? void 0 : _a4.limit) || "")}
`;
    }
    output += "\n";
    totalIssues += results.lineLimit.issues.length;
  }
  if (!results.folderLimit.skipped && results.folderLimit.issues.length > 0) {
    output += `\u{1F4C1} FOLDERS OVER ITEM LIMIT - ${results.folderLimit.issues.length} folders
`;
    for (const issue of results.folderLimit.issues) {
      output += `   ${issue.file}/ - ${issue.count} items (limit: ${issue.limit})
`;
    }
    if (results.folderLimit.prompt) {
      output += `
   \u2192 ${results.folderLimit.prompt.replace(/\{\{\s*folderlimit\s*\}\}/gi, ((_b = results.folderLimit.issues[0]) == null ? void 0 : _b.limit) || "")}
`;
    }
    output += "\n";
    totalIssues += results.folderLimit.issues.length;
  }
  if (!results.missingTests.skipped && results.missingTests.issues.length > 0) {
    output += `\u{1F9EA} MISSING TESTS - ${results.missingTests.issues.length} files
`;
    for (const issue of results.missingTests.issues.slice(0, 10)) {
      output += `   ${issue.file} \u2192 needs ${issue.expectedTest}
`;
    }
    if (results.missingTests.issues.length > 10) {
      output += `   ... and ${results.missingTests.issues.length - 10} more
`;
    }
    output += "\n";
    totalIssues += results.missingTests.issues.length;
  }
  if (results.customRequirements) {
    output += `\u{1F4CB} CUSTOM REQUIREMENTS
`;
    output += `   ${results.customRequirements}

`;
  }
  return { output, totalIssues };
}
var init_analyzer = __esm({
  "src/analyzer.js"() {
  }
});

// src/bburn.js
var bburn_exports = {};
__export(bburn_exports, {
  main: () => main
});
function loadConfig() {
  const configPath = join(process.cwd(), BONZAI_DIR, CONFIG_FILE);
  if (!fs4.existsSync(configPath)) {
    console.error(`\u274C No config found at ${BONZAI_DIR}/${CONFIG_FILE}`);
    console.error(`   Run 'bonzai-burn' to initialize.
`);
    process.exit(1);
  }
  try {
    const content = fs4.readFileSync(configPath, "utf-8");
    return JSON.parse(content);
  } catch (e) {
    console.error(`\u274C Could not parse ${BONZAI_DIR}/${CONFIG_FILE}`);
    process.exit(1);
  }
}
async function main() {
  console.log("\n\u{1F525} Finding unused code...\n");
  const config = loadConfig();
  const results = await analyze(process.cwd(), config);
  const { output, totalIssues } = formatAnalysisResults(results);
  if (totalIssues > 0 || results.customRequirements) {
    console.log("\u2500".repeat(50));
    console.log(`
\u{1F525} Found tech debt:
`);
    console.log(output);
    console.log("\u2500".repeat(50));
    console.log(`${totalIssues} issues across ${results.filesScanned} files (${results.durationMs}ms)
`);
    try {
      execSync("pbcopy", { input: output });
      console.log('Issues copied to clipboard. Run "claude" to implement.\n');
    } catch {
      console.log("Copy the above and give to Claude.\n");
    }
  } else {
    console.log("\u2713 No issues found\n");
  }
}
var BONZAI_DIR, CONFIG_FILE, _a, isDirectRun;
var init_bburn = __esm({
  "src/bburn.js"() {
    init_analyzer();
    BONZAI_DIR = "bonzai";
    CONFIG_FILE = "config.json";
    isDirectRun = (_a = process.argv[1]) == null ? void 0 : _a.endsWith("bburn.js");
    if (isDirectRun) {
      main().catch((error) => {
        console.error("Error:", error.message);
        process.exit(1);
      });
    }
  }
});

// src/bhook.js
var bhook_exports = {};
__export(bhook_exports, {
  main: () => main2
});
function loadBonzaiConfig() {
  const configPath = join(process.cwd(), BONZAI_DIR2, CONFIG_FILE2);
  if (!fs4.existsSync(configPath)) {
    return null;
  }
  try {
    const content = fs4.readFileSync(configPath, "utf-8");
    return JSON.parse(content);
  } catch (e) {
    return null;
  }
}
function loadClaudeSettings() {
  const settingsPath = join(process.cwd(), CLAUDE_DIR, SETTINGS_FILE);
  if (!fs4.existsSync(settingsPath)) {
    return {};
  }
  try {
    const content = fs4.readFileSync(settingsPath, "utf-8");
    return JSON.parse(content);
  } catch (e) {
    return {};
  }
}
function saveClaudeSettings(settings) {
  const claudeDir = join(process.cwd(), CLAUDE_DIR);
  const settingsPath = join(claudeDir, SETTINGS_FILE);
  if (!fs4.existsSync(claudeDir)) {
    fs4.mkdirSync(claudeDir, { recursive: true });
  }
  fs4.writeFileSync(settingsPath, JSON.stringify(settings, null, 2) + "\n");
}
function hasBburnHook(settings) {
  var _a4;
  const stopHooks = ((_a4 = settings.hooks) == null ? void 0 : _a4.Stop) || [];
  return stopHooks.some(
    (entry) => {
      var _a5;
      return (_a5 = entry.hooks) == null ? void 0 : _a5.some((hook) => hook.command === "bburn");
    }
  );
}
function installHook() {
  const settings = loadClaudeSettings();
  if (hasBburnHook(settings)) {
    console.log("\u2713 bburn hook already installed\n");
    return;
  }
  if (!settings.hooks) {
    settings.hooks = {};
  }
  if (!settings.hooks.Stop) {
    settings.hooks.Stop = [];
  }
  settings.hooks.Stop.push({
    hooks: [
      {
        type: "command",
        command: "bburn"
      }
    ]
  });
  saveClaudeSettings(settings);
  console.log("\u2713 Installed bburn as Claude Code Stop hook");
  console.log("  bburn will run after every Claude Code message\n");
}
function uninstallHook() {
  const settings = loadClaudeSettings();
  if (!hasBburnHook(settings)) {
    console.log("\u2713 bburn hook not installed\n");
    return;
  }
  settings.hooks.Stop = settings.hooks.Stop.filter(
    (entry) => {
      var _a4;
      return !((_a4 = entry.hooks) == null ? void 0 : _a4.some((hook) => hook.command === "bburn"));
    }
  );
  if (settings.hooks.Stop.length === 0) {
    delete settings.hooks.Stop;
  }
  if (Object.keys(settings.hooks).length === 0) {
    delete settings.hooks;
  }
  saveClaudeSettings(settings);
  console.log("\u2713 Removed bburn hook from Claude Code\n");
}
function showStatus() {
  var _a4;
  const settings = loadClaudeSettings();
  const config = loadBonzaiConfig();
  console.log("\n\u{1F525} Bonzai Hook Status\n");
  const autoBurnEnabled = ((_a4 = config == null ? void 0 : config.autoBurn) == null ? void 0 : _a4.enabled) ?? false;
  console.log(`Config autoBurn: ${autoBurnEnabled ? "enabled" : "disabled"}`);
  const hookInstalled = hasBburnHook(settings);
  console.log(`Claude hook: ${hookInstalled ? "installed" : "not installed"}
`);
  if (autoBurnEnabled && !hookInstalled) {
    console.log('Run "bhook install" to install the hook\n');
  }
}
async function main2(subArgs = []) {
  const args = subArgs.length > 0 ? subArgs : process.argv.slice(2);
  const command = args[0];
  switch (command) {
    case "uninstall":
    case "remove":
    case "-u":
      uninstallHook();
      break;
    case "status":
    case "-s":
      showStatus();
      break;
    case "install":
    case "-i":
    default:
      installHook();
      break;
  }
}
var BONZAI_DIR2, CONFIG_FILE2, CLAUDE_DIR, SETTINGS_FILE, _a2, isDirectRun2;
var init_bhook = __esm({
  "src/bhook.js"() {
    BONZAI_DIR2 = "bonzai";
    CONFIG_FILE2 = "config.json";
    CLAUDE_DIR = ".claude";
    SETTINGS_FILE = "settings.local.json";
    isDirectRun2 = (_a2 = process.argv[1]) == null ? void 0 : _a2.endsWith("bhook.js");
    if (isDirectRun2) {
      main2().catch((error) => {
        console.error("Error:", error.message);
        process.exit(1);
      });
    }
  }
});

// src/bconfig.js
var bconfig_exports = {};
__export(bconfig_exports, {
  main: () => main3
});
function copyDirectory(src, dest) {
  if (!fs4.existsSync(dest)) {
    fs4.mkdirSync(dest, { recursive: true });
  }
  const entries = fs4.readdirSync(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = path2.join(src, entry.name);
    const destPath = path2.join(dest, entry.name);
    if (entry.isDirectory()) {
      copyDirectory(srcPath, destPath);
    } else {
      fs4.copyFileSync(srcPath, destPath);
    }
  }
}
async function main3() {
  const currentDir = process.cwd();
  const bonzaiDir = path2.join(currentDir, "bonzai");
  const receiverPath = path2.join(bonzaiDir, "receiver.js");
  console.log("Setting up local file server...");
  if (!fs4.existsSync(bonzaiDir)) {
    console.log("Creating bonzai directory...");
    fs4.mkdirSync(bonzaiDir);
  }
  console.log("Writing receiver.js...");
  const receiverContent = fs4.readFileSync(path2.join(TEMPLATE_DIR, "receiver.js"), "utf8");
  fs4.writeFileSync(receiverPath, receiverContent);
  fs4.chmodSync(receiverPath, "755");
  console.log("Writing config.js...");
  const configContent = fs4.readFileSync(path2.join(TEMPLATE_DIR, "config.js"), "utf8");
  fs4.writeFileSync(path2.join(bonzaiDir, "config.js"), configContent);
  console.log("Copying handlers...");
  const handlersDest = path2.join(bonzaiDir, "handlers");
  if (!fs4.existsSync(handlersDest)) {
    fs4.mkdirSync(handlersDest, { recursive: true });
  }
  if (ENABLED_LOOPS.includes("visualization")) {
    const vizSrc = path2.join(TEMPLATE_DIR, "loops", "visualization");
    if (fs4.existsSync(vizSrc)) {
      for (const file of fs4.readdirSync(vizSrc)) {
        fs4.copyFileSync(path2.join(vizSrc, file), path2.join(handlersDest, file));
      }
    }
  }
  if (ENABLED_LOOPS.includes("backend")) {
    const backendSrc = path2.join(TEMPLATE_DIR, "loops", "backend");
    if (fs4.existsSync(backendSrc)) {
      for (const file of fs4.readdirSync(backendSrc)) {
        fs4.copyFileSync(path2.join(backendSrc, file), path2.join(handlersDest, file));
      }
    }
  }
  console.log("Copying utils...");
  const utilsSrc = path2.join(TEMPLATE_DIR, "utils");
  const utilsDest = path2.join(bonzaiDir, "utils");
  copyDirectory(utilsSrc, utilsDest);
  const ignoreTargetPath = path2.join(bonzaiDir, ".ignore");
  if (!fs4.existsSync(ignoreTargetPath)) {
    console.log("Writing .ignore file...");
    const ignoreContent = fs4.readFileSync(path2.join(TEMPLATE_DIR, "ignore.txt"), "utf8");
    fs4.writeFileSync(ignoreTargetPath, ignoreContent);
  }
  const packageJsonPath = path2.join(bonzaiDir, "package.json");
  let packageJson = {};
  if (fs4.existsSync(packageJsonPath)) {
    packageJson = JSON.parse(fs4.readFileSync(packageJsonPath, "utf8"));
  } else {
    packageJson = {
      name: "bonzai-server",
      version: "1.0.0",
      description: "Dependencies for bonzai graph server",
      main: "receiver.js",
      scripts: {
        test: 'echo "Error: no test specified" && exit 1'
      },
      author: "",
      license: "ISC"
    };
  }
  if (!packageJson.dependencies) {
    packageJson.dependencies = {};
  }
  packageJson.dependencies.express = "^4.18.2";
  packageJson.dependencies.cors = "^2.8.5";
  packageJson.dependencies["@babel/parser"] = "^7.23.0";
  packageJson.dependencies.ws = "^8.14.2";
  packageJson.dependencies["node-pty"] = "^1.0.0";
  if (!packageJson.scripts) {
    packageJson.scripts = {};
  }
  packageJson.scripts["file-server"] = "node receiver.js";
  fs4.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
  console.log("Installing dependencies...");
  return new Promise((resolve, reject) => {
    const npm = spawn("npm", ["install"], {
      stdio: "inherit",
      cwd: bonzaiDir
    });
    npm.on("close", (code) => {
      if (code === 0) {
        const nodePtyPrebuilds = path2.join(bonzaiDir, "node_modules", "node-pty", "prebuilds");
        if (fs4.existsSync(nodePtyPrebuilds)) {
          const archDirs = ["darwin-arm64", "darwin-x64", "linux-x64", "linux-arm64"];
          for (const arch of archDirs) {
            const spawnHelperPath = path2.join(nodePtyPrebuilds, arch, "spawn-helper");
            if (fs4.existsSync(spawnHelperPath)) {
              try {
                fs4.chmodSync(spawnHelperPath, "755");
                console.log(`Fixed node-pty spawn-helper permissions (${arch})`);
              } catch (e) {
                console.warn(`Warning: Could not fix spawn-helper permissions for ${arch}:`, e.message);
              }
            }
          }
        }
        console.log("\nListener endpoints successfully deployed");
        console.log("All code stays on your machine\n");
        console.log("Relay server running on localhost:3001");
        console.log("Terminal WebSocket available at ws://localhost:3001/terminal");
        console.log("Diagram available at https://bonzai.dev/\n");
        const server = spawn("node", ["receiver.js"], {
          stdio: "inherit",
          cwd: bonzaiDir,
          env: {
            ...process.env,
            BONZAI_REPO_DIR: currentDir
          }
        });
        exec("open https://bonzai.dev/");
        server.on("close", (serverCode) => {
          console.log(`
Server stopped with code ${serverCode}`);
          process.exit(serverCode);
        });
        server.on("error", (err) => {
          console.error("Error starting server:", err.message);
          process.exit(1);
        });
        process.on("SIGINT", () => {
          console.log("\nShutting down server...");
          server.kill("SIGINT");
        });
        process.on("SIGTERM", () => {
          console.log("\nShutting down server...");
          server.kill("SIGTERM");
        });
        resolve();
      } else {
        reject(new Error("npm install failed with code " + code));
      }
    });
    npm.on("error", (err) => {
      reject(err);
    });
  });
}
var __filename$1, __dirname$1, TEMPLATE_DIR, _a3, isDirectRun3;
var init_bconfig = __esm({
  "src/bconfig.js"() {
    init_loops_config();
    __filename$1 = fileURLToPath(import.meta.url);
    __dirname$1 = path2.dirname(__filename$1);
    TEMPLATE_DIR = path2.join(__dirname$1, "graph-templates");
    isDirectRun3 = (_a3 = process.argv[1]) == null ? void 0 : _a3.endsWith("bconfig.js");
    if (isDirectRun3) {
      main3().catch(console.error);
    }
  }
});

// src/index.js
init_loops_config();
var __filename2 = fileURLToPath(import.meta.url);
var __dirname2 = dirname(__filename2);
var BONZAI_DIR3 = "bonzai";
var TEMPLATE_DIR2 = join(__dirname2, "payload-bonzai");
function showHelp() {
  let help = `
Usage: npx bonzai-burn [option]

Options:
  (no option)   Initialize bonzai in current directory
  -b, --burn    Run code analysis
  -h, --hook    Manage Claude Code stop hook
  --help        Show this help message`;
  if (ENABLED_LOOPS.includes("visualization") || ENABLED_LOOPS.includes("backend")) {
    help = help.replace("--help", "-g, --graph   Launch visualization server\n  --help");
  }
  console.log(help);
}
function init() {
  const currentDir = process.cwd();
  const bonzaiPath = join(currentDir, BONZAI_DIR3);
  if (existsSync(bonzaiPath)) {
    console.log(`${BONZAI_DIR3}/ already exists`);
    return;
  }
  mkdirSync(bonzaiPath, { recursive: true });
  copyFileSync(join(TEMPLATE_DIR2, "config.json"), join(bonzaiPath, "config.json"));
  console.log(`Created ${BONZAI_DIR3}/ folder with config.json`);
  console.log(`Edit ${BONZAI_DIR3}/config.json to configure your burn rules`);
  console.log("");
  console.log("  \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510");
  console.log("  \u2502  npx bonzai-burn -g   Launch dependency graph        \u2502");
  console.log("  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518");
}
async function main4() {
  const args = process.argv.slice(2);
  const flag = args[0];
  if (ENABLED_LOOPS.includes("burn")) {
    if (flag === "-b" || flag === "--burn") {
      const { main: burnMain } = await Promise.resolve().then(() => (init_bburn(), bburn_exports));
      return burnMain == null ? void 0 : burnMain();
    }
    if (flag === "-h" || flag === "--hook") {
      const { main: hookMain } = await Promise.resolve().then(() => (init_bhook(), bhook_exports));
      return hookMain == null ? void 0 : hookMain(args.slice(1));
    }
  }
  if (ENABLED_LOOPS.includes("visualization") || ENABLED_LOOPS.includes("backend")) {
    if (flag === "-g" || flag === "--graph") {
      const { main: configMain } = await Promise.resolve().then(() => (init_bconfig(), bconfig_exports));
      return configMain == null ? void 0 : configMain();
    }
  }
  if (flag === "--help") {
    showHelp();
    return;
  }
  init();
}
main4().catch((error) => {
  console.error("Error:", error.message);
  process.exit(1);
});
