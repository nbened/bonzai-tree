import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

/**
 * Static analyzer for codebase
 * Runs ESLint, TypeScript, and custom checks based on config.json
 */

/**
 * Check if a command exists
 */
function commandExists(cmd) {
  try {
    execSync(`which ${cmd}`, { encoding: 'utf-8', stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if package is installed locally
 */
function isInstalledLocally(pkg, rootDir) {
  return fs.existsSync(path.join(rootDir, 'node_modules', pkg));
}

/**
 * Install a package as dev dependency
 */
function installPackage(pkg, rootDir) {
  try {
    console.log(`   Installing ${pkg}...`);
    execSync(`cd "${rootDir}" && npm install --save-dev ${pkg}`, {
      encoding: 'utf-8',
      stdio: 'pipe'
    });
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Check if ESLint config file exists (supports ESLint v9 flat config)
 */
function hasEslintConfig(rootDir) {
  const configFiles = [
    'eslint.config.js',
    'eslint.config.mjs',
    'eslint.config.cjs',
    // Legacy configs (ESLint < 9)
    '.eslintrc.js',
    '.eslintrc.cjs',
    '.eslintrc.json',
    '.eslintrc.yml',
    '.eslintrc.yaml',
    '.eslintrc'
  ];

  return configFiles.some(file => fs.existsSync(path.join(rootDir, file)));
}

/**
 * Create a minimal ESLint v9 flat config
 */
function createEslintConfig(rootDir, config) {
  const rules = config.eslint?.rules || ['no-unused-vars'];

  // Build rules object
  const rulesObj = {};
  for (const rule of rules) {
    rulesObj[rule] = 'error';
  }

  const rulesJson = JSON.stringify(rulesObj, null, 2).replace(/\n/g, '\n    ');
  const configContent = `// Auto-generated by bonzai-burn for ESLint v9+
export default [
  {
    files: ['**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx', '**/*.mjs', '**/*.cjs'],
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'module',
      parserOptions: {
        ecmaFeatures: {
          jsx: true
        }
      }
    },
    rules: ${rulesJson}
  }
];
`;

  const configPath = path.join(rootDir, 'eslint.config.js');
  try {
    fs.writeFileSync(configPath, configContent, 'utf-8');
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Ensure ESLint is available
 */
function ensureEslint(rootDir, config) {
  const cfg = config.eslint || {};
  if (!cfg.enabled) {
    return { available: false, reason: 'Disabled in config' };
  }

  // Check if eslint exists globally or locally
  let eslintInstalled = commandExists('eslint') || isInstalledLocally('eslint', rootDir);
  let installed = false;

  if (!eslintInstalled) {
    // Try to install
    console.log('ðŸ“¦ ESLint not found, installing...');
    if (installPackage('eslint', rootDir)) {
      eslintInstalled = true;
      installed = true;
    } else {
      return { available: false, reason: 'Failed to install ESLint' };
    }
  }

  // Ensure ESLint config exists (required for ESLint v9+)
  let configCreated = false;
  if (!hasEslintConfig(rootDir)) {
    console.log('ðŸ“„ Creating eslint.config.js...');
    if (createEslintConfig(rootDir, config)) {
      configCreated = true;
    } else {
      return { available: false, reason: 'Failed to create ESLint config' };
    }
  }

  return { available: true, installed, configCreated };
}

/**
 * Ensure TypeScript is available
 */
function ensureTypeScript(rootDir, config) {
  const cfg = config.typescript || {};
  if (!cfg.enabled) {
    return { available: false, reason: 'Disabled in config' };
  }

  // Check if tsconfig exists (otherwise no point)
  if (!fs.existsSync(path.join(rootDir, 'tsconfig.json'))) {
    return { available: false, reason: 'No tsconfig.json found' };
  }

  // Check if tsc exists globally or locally
  if (commandExists('tsc') || isInstalledLocally('typescript', rootDir)) {
    return { available: true };
  }

  // Try to install
  console.log('ðŸ“¦ TypeScript not found, installing...');
  if (installPackage('typescript', rootDir)) {
    return { available: true, installed: true };
  }

  return { available: false, reason: 'Failed to install TypeScript' };
}

/**
 * List all files recursively, respecting common ignore patterns
 */
function listAllFiles(dir, basePath = '') {
  const ignorePatterns = ['node_modules', '.git', '.DS_Store', 'dist', 'build', 'coverage', 'bonzai'];
  let results = [];

  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      const relativePath = path.join(basePath, entry.name);

      if (ignorePatterns.some(p => entry.name === p) || entry.name.startsWith('.')) {
        continue;
      }

      if (entry.isDirectory()) {
        results = results.concat(listAllFiles(fullPath, relativePath));
      } else {
        results.push({
          path: relativePath,
          fullPath: fullPath
        });
      }
    }
  } catch (e) {
    // Directory access error, skip
  }

  return results;
}

/**
 * Run ESLint to detect unused imports and variables
 */
function runEslintAnalysis(rootDir, config) {
  const issues = [];
  const cfg = config.eslint || {};

  if (!cfg.enabled) {
    return { issues, skipped: true, reason: 'Disabled in config' };
  }

  // Build rules from config
  const rules = cfg.rules || ['no-unused-vars'];
  const ruleArgs = rules.map(r => `--rule "${r}: error"`).join(' ');

  // Try local eslint first, then global
  const eslintCmd = isInstalledLocally('eslint', rootDir)
    ? `"${path.join(rootDir, 'node_modules', '.bin', 'eslint')}"`
    : 'eslint';

  try {
    const result = execSync(
      `${eslintCmd} "${rootDir}" --format json ${ruleArgs} --ignore-pattern node_modules --ignore-pattern bonzai 2>/dev/null || true`,
      { encoding: 'utf-8', stdio: 'pipe', maxBuffer: 50 * 1024 * 1024 }
    );

    if (result.trim()) {
      const eslintOutput = JSON.parse(result);

      for (const file of eslintOutput) {
        for (const msg of file.messages || []) {
          if (msg.ruleId && rules.some(r => msg.ruleId.includes(r.replace('no-', '')))) {
            issues.push({
              file: path.relative(rootDir, file.filePath),
              line: msg.line,
              message: msg.message,
              rule: msg.ruleId
            });
          }
        }
      }
    }
  } catch (e) {
    return { issues, skipped: true, reason: 'ESLint analysis failed' };
  }

  return { issues, skipped: false };
}

/**
 * Run TypeScript compiler to check for unused locals
 */
function runTypeScriptAnalysis(rootDir, config) {
  const issues = [];
  const cfg = config.typescript || {};

  if (!cfg.enabled) {
    return { issues, skipped: true, reason: 'Disabled in config' };
  }

  const tsconfigPath = path.join(rootDir, 'tsconfig.json');
  if (!fs.existsSync(tsconfigPath)) {
    return { issues, skipped: true, reason: 'No tsconfig.json found' };
  }

  // Try local tsc first, then global
  const tscCmd = isInstalledLocally('typescript', rootDir)
    ? `"${path.join(rootDir, 'node_modules', '.bin', 'tsc')}"`
    : 'tsc';

  try {
    const result = execSync(
      `cd "${rootDir}" && ${tscCmd} --noEmit --noUnusedLocals --noUnusedParameters 2>&1 || true`,
      { encoding: 'utf-8', stdio: 'pipe', maxBuffer: 50 * 1024 * 1024 }
    );

    const lines = result.split('\n');
    const errorRegex = /^(.+)\((\d+),(\d+)\):\s*error\s+TS(\d+):\s*(.+)$/;

    for (const line of lines) {
      const match = line.match(errorRegex);
      if (match) {
        const [, filePath, lineNum, , errorCode, message] = match;
        // TS6133 = unused variable, TS6196 = unused parameter
        if (['6133', '6196', '6198'].includes(errorCode)) {
          issues.push({
            file: path.relative(rootDir, filePath),
            line: parseInt(lineNum, 10),
            message: message,
            rule: `TS${errorCode}`
          });
        }
      }
    }
  } catch (e) {
    return { issues, skipped: true, reason: 'TypeScript analysis failed' };
  }

  return { issues, skipped: false };
}

/**
 * Check files against line limit
 */
function checkLineLimits(files, config) {
  const issues = [];
  const cfg = config.lineLimit || {};

  if (!cfg.enabled) {
    return { issues, skipped: true, reason: 'Disabled in config' };
  }

  const maxLines = cfg.limit || 500;

  for (const file of files) {
    // Skip non-code files
    if (file.path.endsWith('.json') || file.path.endsWith('.lock') || file.path.endsWith('.css')) {
      continue;
    }

    try {
      const content = fs.readFileSync(file.fullPath, 'utf-8');
      const lineCount = content.split('\n').length;

      if (lineCount > maxLines) {
        issues.push({
          file: file.path,
          count: lineCount,
          limit: maxLines
        });
      }
    } catch (e) {
      // Can't read file, skip
    }
  }

  issues.sort((a, b) => b.count - a.count);
  return { issues, skipped: false, prompt: cfg.prompt };
}

/**
 * Check folders against item limit
 */
function checkFolderLimits(files, config) {
  const issues = [];
  const cfg = config.folderLimit || {};

  if (!cfg.enabled) {
    return { issues, skipped: true, reason: 'Disabled in config' };
  }

  const maxItems = cfg.limit || 20;
  const folderCounts = {};

  for (const file of files) {
    const dir = path.dirname(file.path);
    if (!folderCounts[dir]) {
      folderCounts[dir] = 0;
    }
    folderCounts[dir]++;
  }

  for (const [folder, count] of Object.entries(folderCounts)) {
    if (count > maxItems) {
      issues.push({
        file: folder,
        count: count,
        limit: maxItems
      });
    }
  }

  issues.sort((a, b) => b.count - a.count);
  return { issues, skipped: false, prompt: cfg.prompt };
}

/**
 * Check for missing test files
 */
function checkMissingTests(files, config) {
  const issues = [];
  const cfg = config.testCheck || {};

  if (!cfg.enabled) {
    return { issues, skipped: true, reason: 'Disabled in config' };
  }

  const patterns = cfg.patterns || {
    '.vue': '.test.js',
    '.jsx': '.test.jsx',
    '.tsx': '.test.tsx'
  };

  const testFiles = new Set(
    files
      .filter(f => f.path.includes('.test.') || f.path.includes('.spec.'))
      .map(f => f.path.toLowerCase())
  );

  for (const file of files) {
    const ext = path.extname(file.path);
    const testExt = patterns[ext];

    if (!testExt) continue;
    if (file.path.includes('.test.') || file.path.includes('.spec.')) continue;
    if (!file.path.startsWith('src/') && !file.path.startsWith('components/')) continue;

    const baseName = path.basename(file.path, ext);
    const hasTest = [...testFiles].some(t => t.includes(baseName.toLowerCase()) && t.includes('.test.'));

    if (!hasTest) {
      issues.push({
        file: file.path,
        expectedTest: `${baseName}${testExt}`
      });
    }
  }

  return { issues, skipped: false, prompt: cfg.prompt };
}

/**
 * Main analyzer function
 */
export async function analyze(rootDir = process.cwd(), config = {}) {
  const startTime = Date.now();
  const files = listAllFiles(rootDir);
  const toolStatus = {};

  // Ensure tools are available (auto-install if needed)
  console.log('ðŸ”§ Checking tools...');

  const eslintStatus = ensureEslint(rootDir, config);
  toolStatus.eslint = eslintStatus;
  if (eslintStatus.installed && eslintStatus.configCreated) {
    console.log('   âœ“ ESLint installed + config created');
  } else if (eslintStatus.installed) {
    console.log('   âœ“ ESLint installed');
  } else if (eslintStatus.configCreated) {
    console.log('   âœ“ ESLint ready (config created)');
  } else if (eslintStatus.available) {
    console.log('   âœ“ ESLint ready');
  } else if (config.eslint?.enabled) {
    console.log(`   âœ— ESLint: ${eslintStatus.reason}`);
  }

  const tsStatus = ensureTypeScript(rootDir, config);
  toolStatus.typescript = tsStatus;
  if (tsStatus.installed) {
    console.log('   âœ“ TypeScript installed');
  } else if (tsStatus.available) {
    console.log('   âœ“ TypeScript ready');
  } else if (config.typescript?.enabled) {
    console.log(`   âœ— TypeScript: ${tsStatus.reason}`);
  }

  console.log('');

  // Run checks
  const eslint = eslintStatus.available
    ? runEslintAnalysis(rootDir, config)
    : { issues: [], skipped: true, reason: eslintStatus.reason };

  const typescript = tsStatus.available
    ? runTypeScriptAnalysis(rootDir, config)
    : { issues: [], skipped: true, reason: tsStatus.reason };

  const lineLimit = checkLineLimits(files, config);
  const folderLimit = checkFolderLimits(files, config);
  const missingTests = checkMissingTests(files, config);

  const duration = Date.now() - startTime;

  return {
    eslint,
    typescript,
    lineLimit,
    folderLimit,
    missingTests,
    customRequirements: config.customChecks?.requirements || null,
    filesScanned: files.length,
    durationMs: duration,
    toolStatus
  };
}

/**
 * Format analysis results for display
 */
export function formatAnalysisResults(results) {
  let output = '';
  let totalIssues = 0;

  // ESLint issues
  if (!results.eslint.skipped && results.eslint.issues.length > 0) {
    output += `ðŸ—‘ï¸  UNUSED CODE (ESLint) - ${results.eslint.issues.length} issues\n`;
    for (const issue of results.eslint.issues.slice(0, 15)) {
      output += `   ${issue.file}:${issue.line} - ${issue.message}\n`;
    }
    if (results.eslint.issues.length > 15) {
      output += `   ... and ${results.eslint.issues.length - 15} more\n`;
    }
    output += '\n';
    totalIssues += results.eslint.issues.length;
  }

  // TypeScript issues
  if (!results.typescript.skipped && results.typescript.issues.length > 0) {
    output += `ðŸ”· UNUSED CODE (TypeScript) - ${results.typescript.issues.length} issues\n`;
    for (const issue of results.typescript.issues.slice(0, 15)) {
      output += `   ${issue.file}:${issue.line} - ${issue.message}\n`;
    }
    if (results.typescript.issues.length > 15) {
      output += `   ... and ${results.typescript.issues.length - 15} more\n`;
    }
    output += '\n';
    totalIssues += results.typescript.issues.length;
  }

  // Line limit issues
  if (!results.lineLimit.skipped && results.lineLimit.issues.length > 0) {
    output += `ðŸ“ FILES OVER LINE LIMIT - ${results.lineLimit.issues.length} files\n`;
    for (const issue of results.lineLimit.issues) {
      output += `   ${issue.file} - ${issue.count} lines (limit: ${issue.limit})\n`;
    }
    if (results.lineLimit.prompt) {
      output += `\n   â†’ ${results.lineLimit.prompt.replace(/\{\{\s*linelimit\s*\}\}/gi, results.lineLimit.issues[0]?.limit || '')}\n`;
    }
    output += '\n';
    totalIssues += results.lineLimit.issues.length;
  }

  // Folder limit issues
  if (!results.folderLimit.skipped && results.folderLimit.issues.length > 0) {
    output += `ðŸ“ FOLDERS OVER ITEM LIMIT - ${results.folderLimit.issues.length} folders\n`;
    for (const issue of results.folderLimit.issues) {
      output += `   ${issue.file}/ - ${issue.count} items (limit: ${issue.limit})\n`;
    }
    if (results.folderLimit.prompt) {
      output += `\n   â†’ ${results.folderLimit.prompt.replace(/\{\{\s*folderlimit\s*\}\}/gi, results.folderLimit.issues[0]?.limit || '')}\n`;
    }
    output += '\n';
    totalIssues += results.folderLimit.issues.length;
  }

  // Missing tests
  if (!results.missingTests.skipped && results.missingTests.issues.length > 0) {
    output += `ðŸ§ª MISSING TESTS - ${results.missingTests.issues.length} files\n`;
    for (const issue of results.missingTests.issues.slice(0, 10)) {
      output += `   ${issue.file} â†’ needs ${issue.expectedTest}\n`;
    }
    if (results.missingTests.issues.length > 10) {
      output += `   ... and ${results.missingTests.issues.length - 10} more\n`;
    }
    output += '\n';
    totalIssues += results.missingTests.issues.length;
  }

  // Custom requirements
  if (results.customRequirements) {
    output += `ðŸ“‹ CUSTOM REQUIREMENTS\n`;
    output += `   ${results.customRequirements}\n\n`;
  }

  return { output, totalIssues };
}

export default { analyze, formatAnalysisResults };
